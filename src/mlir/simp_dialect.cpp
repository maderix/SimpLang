//===- simp_dialect.cpp - Simp dialect implementation ---------------------===//
//
// Part of the SimpLang Project
//
// This file implements the Simp dialect class.
//
//===----------------------------------------------------------------------===//

#include "mlir/simp_dialect.hpp"
#include "mlir/simp_ops.hpp"
#include "mlir/simp_types.hpp"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/DialectImplementation.h"
#include "mlir/IR/OpImplementation.h"
#include "llvm/ADT/TypeSwitch.h"

using namespace mlir;
using namespace mlir::simp;

//===----------------------------------------------------------------------===//
// Simp Dialect
//===----------------------------------------------------------------------===//

// Include generated dialect definitions
#include "SimpDialect.cpp.inc"

// The constructor is generated by TableGen, we just implement initialize()
void SimpDialect::initialize() {
  // Register types
  addTypes<ArrayType, SimpTensorType>();

  // Register operations
  addOperations<
#define GET_OP_LIST
#include "SimpOps.cpp.inc"
  >();
}

//===----------------------------------------------------------------------===//
// Constant Materialization
//===----------------------------------------------------------------------===//

mlir::Operation *SimpDialect::materializeConstant(mlir::OpBuilder &builder,
                                                   mlir::Attribute value,
                                                   mlir::Type type,
                                                   mlir::Location loc) {
  // Create a simp.constant operation for the given value and type
  return builder.create<simp::ConstantOp>(loc, type, value);
}

//===----------------------------------------------------------------------===//
// Type Printing and Parsing
//===----------------------------------------------------------------------===//

mlir::Type SimpDialect::parseType(mlir::DialectAsmParser &parser) const {
  llvm::StringRef typeTag;
  if (parser.parseKeyword(&typeTag))
    return Type();

  if (typeTag == "array") {
    // Parse: array<element-type>
    mlir::Type elemType;
    if (parser.parseLess() || parser.parseType(elemType) || parser.parseGreater())
      return Type();
    return ArrayType::get(getContext(), elemType);
  }

  if (typeTag == "tensor") {
    // Parse: tensor<shape>
    // For now, just error - full tensor parsing would go here
    parser.emitError(parser.getNameLoc(), "tensor type parsing not yet implemented");
    return Type();
  }

  parser.emitError(parser.getNameLoc(), "unknown simp type: ") << typeTag;
  return Type();
}

void SimpDialect::printType(mlir::Type type, mlir::DialectAsmPrinter &printer) const {
  if (auto arrayType = type.dyn_cast<ArrayType>()) {
    printer << "array<";
    printer.printType(arrayType.getElementType());
    printer << ">";
  } else if (auto tensorType = type.dyn_cast<SimpTensorType>()) {
    printer << "tensor<";
    // Print shape
    for (size_t i = 0; i < tensorType.getShape().size(); ++i) {
      if (i > 0) printer << "x";
      int64_t dim = tensorType.getShape()[i];
      if (dim == -1)
        printer << "?";
      else
        printer << dim;
    }
    printer << "x";
    printer.printType(tensorType.getElementType());
    printer << ">";
  } else {
    llvm_unreachable("unhandled simp type");
  }
}

//===----------------------------------------------------------------------===//
// Operation Definitions
//===----------------------------------------------------------------------===//

// Include generated operation definitions
#define GET_OP_CLASSES
#include "SimpOps.cpp.inc"
