
SIMDY Code Dump - Wed Oct 30 21:54:47 IST 2024
==================================================================


==================================================================
FILE: CMakeLists.txt
==================================================================
cmake_minimum_required(VERSION 3.10)
project(SimpleLang)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_BUILD_TYPE Debug)

# Find required packages
find_package(LLVM REQUIRED CONFIG)
find_package(BISON REQUIRED)
find_package(FLEX REQUIRED)

message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")
message(STATUS "Using LLVMConfig.cmake in: ${LLVM_DIR}")

include_directories(${LLVM_INCLUDE_DIRS})
add_definitions(${LLVM_DEFINITIONS})

# Add source directory
include_directories(${CMAKE_SOURCE_DIR}/include)
add_subdirectory(src)


==================================================================
FILE: src/CMakeLists.txt
==================================================================
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Generate lexer and parser
BISON_TARGET(Parser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp
             DEFINES_FILE ${CMAKE_CURRENT_BINARY_DIR}/parser.hpp)
FLEX_TARGET(Scanner lexer.l ${CMAKE_CURRENT_BINARY_DIR}/lexer.cpp)
ADD_FLEX_BISON_DEPENDENCY(Scanner Parser)

# Add executable
add_executable(simplang
    main.cpp
    ast.cpp
    codegen.cpp
    ${BISON_Parser_OUTPUTS}
    ${FLEX_Scanner_OUTPUTS}
)

# Include directories
target_include_directories(simplang PRIVATE
    ${CMAKE_SOURCE_DIR}/include
    ${CMAKE_CURRENT_BINARY_DIR}
)

# Link against LLVM libraries
llvm_map_components_to_libnames(llvm_libs
    Core
    Support
    native
    nativecodegen
    x86codegen
    x86asmparser
    x86info
    TransformUtils
    ScalarOpts
    InstCombine
    Analysis
    Target
    MC
    Object
    BitWriter
)

target_link_libraries(simplang ${llvm_libs})


==================================================================
FILE: src/parser.y
==================================================================
%{
    #define YYDEBUG 1
    #include <string>
    #include <vector>
    #include <iostream>
    #include "ast.hpp"

    BlockAST *programBlock;

    extern int yylex();
    extern int yylineno;
    extern char *yytext;
    void yyerror(const char *s) { 
        fprintf(stderr, "Error: %s at symbol \"%s\" on line %d\n", s, yytext, yylineno);
    }
%}

%define parse.trace

%code requires {
    #include "ast.hpp"
}

%union {
    BlockAST *block;
    StmtAST *stmt;
    ExprAST *expr;
    VariableDeclarationAST *var_decl;
    std::vector<ExprAST*> *exprvec;
    std::vector<VariableDeclarationAST*> *varvec;
    std::string *string;
    int token;
}

%token <string> TIDENTIFIER TINTEGER TFLOAT
%token TCEQ TCNE TCLE TCGE
%token TVAR TFUNC TIF TELSE TWHILE TRETURN
%token TLPAREN TRPAREN TLBRACE TRBRACE
%token TCOMMA TSEMICOLON

%left '+' '-'
%left '*' '/'

%type <block> program stmts block
%type <stmt> stmt func_decl if_stmt while_stmt return_stmt
%type <expr> expr numeric ident call_expr
%type <exprvec> call_args
%type <varvec> func_decl_args
%type <var_decl> var_decl param_decl

%%

program : stmts { programBlock = $1; }
        ;

stmts : stmt { $$ = new BlockAST(); $$->statements.push_back($1); }
      | stmts stmt { $1->statements.push_back($2); $$ = $1; }
      ;

stmt : var_decl TSEMICOLON { $$ = $1; }
     | func_decl
     | expr TSEMICOLON { $$ = new ExpressionStmtAST($1); }
     | return_stmt
     | if_stmt
     | while_stmt
     ;

block : TLBRACE stmts TRBRACE { $$ = $2; }
      | TLBRACE TRBRACE { $$ = new BlockAST(); }
      ;

var_decl : TVAR TIDENTIFIER { $$ = new VariableDeclarationAST(*$2, nullptr); }
         | TVAR TIDENTIFIER '=' expr { $$ = new VariableDeclarationAST(*$2, $4); }
         ;

param_decl : TVAR TIDENTIFIER { $$ = new VariableDeclarationAST(*$2, nullptr); }
           ;

func_decl : TFUNC TIDENTIFIER TLPAREN func_decl_args TRPAREN block 
            { $$ = new FunctionAST(*$2, $4, $6); }
          ;

func_decl_args : /* empty */ { $$ = new std::vector<VariableDeclarationAST*>(); }
               | param_decl { $$ = new std::vector<VariableDeclarationAST*>(); $$->push_back($1); }
               | func_decl_args TCOMMA param_decl { $1->push_back($3); $$ = $1; }
               ;

if_stmt : TIF TLPAREN expr TRPAREN block { $$ = new IfAST($3, $5, nullptr); }
        | TIF TLPAREN expr TRPAREN block TELSE block { $$ = new IfAST($3, $5, $7); }
        ;

while_stmt : TWHILE TLPAREN expr TRPAREN block { $$ = new WhileAST($3, $5); }
           ;

return_stmt : TRETURN expr TSEMICOLON { $$ = new ReturnAST($2); }
            ;

expr : expr '+' expr   { $$ = new BinaryExprAST(OpAdd, $1, $3); }
     | expr '-' expr   { $$ = new BinaryExprAST(OpSub, $1, $3); }
     | expr '*' expr   { $$ = new BinaryExprAST(OpMul, $1, $3); }
     | expr '/' expr   { $$ = new BinaryExprAST(OpDiv, $1, $3); }
     | expr TCEQ expr  { $$ = new BinaryExprAST(OpEQ, $1, $3); }
     | expr TCNE expr  { $$ = new BinaryExprAST(OpNE, $1, $3); }
     | expr '<' expr   { $$ = new BinaryExprAST(OpLT, $1, $3); }
     | expr '>' expr   { $$ = new BinaryExprAST(OpGT, $1, $3); }
     | expr TCLE expr  { $$ = new BinaryExprAST(OpLE, $1, $3); }
     | expr TCGE expr  { $$ = new BinaryExprAST(OpGE, $1, $3); }
     | TLPAREN expr TRPAREN { $$ = $2; }
     | ident '=' expr  { $$ = new AssignmentExprAST($1, $3); }
     | call_expr
     | ident
     | numeric
     ;

call_expr : ident TLPAREN call_args TRPAREN { 
            $$ = new CallExprAST(((VariableExprAST*)$1)->getName(), *$3); 
          }
          ;

call_args : /* empty */ { $$ = new std::vector<ExprAST*>(); }
          | expr { $$ = new std::vector<ExprAST*>(); $$->push_back($1); }
          | call_args TCOMMA expr { $1->push_back($3); $$ = $1; }
          ;

ident : TIDENTIFIER { $$ = new VariableExprAST(*$1); }
      ;

numeric : TINTEGER { $$ = new NumberExprAST(atof($1->c_str())); }
        | TFLOAT { $$ = new NumberExprAST(atof($1->c_str())); }
        ;

%%


==================================================================
FILE: src/lexer.l
==================================================================
%option yylineno
%{
#include <string>
#include "parser.hpp"

#define SAVE_TOKEN  yylval.string = new std::string(yytext, yyleng)

extern "C" int yywrap() { return 1; }
%}

%x COMMENT

%%

[ \t\r]+              ;  // Skip whitespace
\n                    { yylineno++; }
"//".*                ;  // Single-line comments
"/*"                  { BEGIN(COMMENT); }  // Start multi-line comment

<COMMENT>"*/"         { BEGIN(INITIAL); }  // End multi-line comment
<COMMENT>\n           { yylineno++; }
<COMMENT>.            ;  // Ignore all characters in comments

[0-9]+\.[0-9]*        { SAVE_TOKEN; return TFLOAT; }
[0-9]+                { SAVE_TOKEN; return TINTEGER; }
"fn"                  { return TFUNC; }
"return"              { return TRETURN; }
"if"                  { return TIF; }
"else"                { return TELSE; }
"while"               { return TWHILE; }
"var"                 { return TVAR; }
[a-zA-Z_][a-zA-Z0-9_]* { SAVE_TOKEN; return TIDENTIFIER; }
"=="                  { return TCEQ; }
"!="                  { return TCNE; }
"<="                  { return TCLE; }
">="                  { return TCGE; }
"("                   { return TLPAREN; }
")"                   { return TRPAREN; }
"{"                   { return TLBRACE; }
"}"                   { return TRBRACE; }
";"                   { return TSEMICOLON; }
","                   { return TCOMMA; }
"="                   { return '='; }
"<"                   { return '<'; }
">"                   { return '>'; }
"+"                   { return '+'; }
"-"                   { return '-'; }
"*"                   { return '*'; }
"/"                   { return '/'; }
.                     { printf("Unknown token: %s\n", yytext); yyterminate(); }

%%


Header Files:


==================================================================
FILE: ./src/codegen.hpp
==================================================================
// codegen.hpp

#ifndef CODEGEN_HPP
#define CODEGEN_HPP

#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/Target/TargetMachine.h>
#include <llvm/Support/TargetSelect.h>
#include <map>
#include <string>
#include <vector>
#include <memory>

class CodeGenBlock {
public:
    std::map<std::string, llvm::Value*> locals;
};

class CodeGenContext {
    std::vector<CodeGenBlock*> blocks;
    llvm::LLVMContext context;
    std::unique_ptr<llvm::Module> module;
    llvm::IRBuilder<> builder;
    std::unique_ptr<llvm::legacy::FunctionPassManager> fpm;
    std::unique_ptr<llvm::TargetMachine> targetMachine;
    std::string targetTriple;

public:
    CodeGenContext();

    llvm::LLVMContext& getContext();
    llvm::Module* getModule();
    llvm::IRBuilder<>& getBuilder();
    llvm::Type* getDoubleType();
    llvm::Function* currentFunction();
    llvm::TargetMachine* getTargetMachine(); // Declaration of getTargetMachine()

    void generateCode(BlockAST& root);
    void pushBlock();
    void popBlock();
    void setSymbolValue(const std::string& name, llvm::Value* value);
    llvm::Value* getSymbolValue(const std::string& name);
};

#endif // CODEGEN_HPP

==================================================================
FILE: ./include/ast.hpp
==================================================================
#ifndef AST_HPP
#define AST_HPP

#include <string>
#include <vector>
#include <memory>
#include <llvm/IR/Value.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Module.h>

class CodeGenContext;

// Define an enumeration for binary operators
enum BinaryOp {
    OpAdd = '+',  // ASCII value of '+'
    OpSub = '-',  // ASCII value of '-'
    OpMul = '*',  // ASCII value of '*'
    OpDiv = '/',  // ASCII value of '/'
    OpLT  = '<',  // ASCII value of '<'
    OpGT  = '>',  // ASCII value of '>'
    OpAssign = '=', // ASCII value of '='
    OpLE  = 256,   // Start from 256 to avoid conflict with ASCII codes
    OpGE,
    OpEQ,
    OpNE
};

// Base AST node class
class AST {
public:
    virtual ~AST() {}
    virtual llvm::Value* codeGen(CodeGenContext& context) = 0;
};

// Expression class
class ExprAST : public AST {
public:
    virtual ~ExprAST() {}
};

// Number literal expression
class NumberExprAST : public ExprAST {
    double value;
public:
    NumberExprAST(double value) : value(value) {}
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// Variable expression
class VariableExprAST : public ExprAST {
    std::string name;
public:
    VariableExprAST(const std::string& name) : name(name) {}
    const std::string& getName() const { return name; }
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// Binary operator expression
class BinaryExprAST : public ExprAST {
    BinaryOp op;
    ExprAST *lhs, *rhs;
public:
    BinaryExprAST(BinaryOp op, ExprAST* lhs, ExprAST* rhs) :
        op(op), lhs(lhs), rhs(rhs) {}
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// Assignment expression
class AssignmentExprAST : public ExprAST {
    VariableExprAST* lhs;
    ExprAST* rhs;
public:
    AssignmentExprAST(ExprAST* lhs, ExprAST* rhs) :
        lhs(dynamic_cast<VariableExprAST*>(lhs)), rhs(rhs) {}
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// Function call expression
class CallExprAST : public ExprAST {
    std::string callee;
    std::vector<ExprAST*> arguments;
public:
    CallExprAST(const std::string& callee, const std::vector<ExprAST*>& args) :
        callee(callee), arguments(args) {}
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// Statement class
class StmtAST : public AST {
public:
    virtual ~StmtAST() {}
};

// Expression statement
class ExpressionStmtAST : public StmtAST {
    ExprAST* expression;
public:
    ExpressionStmtAST(ExprAST* expr) : expression(expr) {}
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// Block statement
class BlockAST : public StmtAST {
public:
    std::vector<StmtAST*> statements;
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// Variable declaration
class VariableDeclarationAST : public StmtAST {
    std::string name;
    ExprAST* assignmentExpr;
public:
    VariableDeclarationAST(const std::string& name, ExprAST* expr = nullptr) :
        name(name), assignmentExpr(expr) {}
    const std::string& getName() const { return name; }
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// Function declaration
class FunctionAST : public StmtAST {
    std::string name;
    std::vector<VariableDeclarationAST*> arguments;
    BlockAST* body;
public:
    FunctionAST(const std::string& name,
                std::vector<VariableDeclarationAST*>* arguments,
                BlockAST* body) :
        name(name), arguments(*arguments), body(body) {}
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// If statement
class IfAST : public StmtAST {
    ExprAST* condition;
    BlockAST *thenBlock, *elseBlock;
public:
    IfAST(ExprAST* condition, BlockAST* thenBlock, BlockAST* elseBlock = nullptr) :
        condition(condition), thenBlock(thenBlock), elseBlock(elseBlock) {}
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// While statement
class WhileAST : public StmtAST {
    ExprAST* condition;
    BlockAST* body;
public:
    WhileAST(ExprAST* condition, BlockAST* body) :
        condition(condition), body(body) {}
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

// Return statement
class ReturnAST : public StmtAST {
    ExprAST* expression;
public:
    ReturnAST(ExprAST* expr) : expression(expr) {}
    virtual llvm::Value* codeGen(CodeGenContext& context);
};

#endif // AST_HPP


Source Files:


==================================================================
FILE: ./src/codegen.cpp
==================================================================
// codegen.cpp

#include "codegen.hpp"
#include "ast.hpp"

#include <llvm/IR/Verifier.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Support/TargetRegistry.h>
#include <llvm/IR/LegacyPassManager.h>

CodeGenContext::CodeGenContext() : builder(context) {
    module = std::make_unique<llvm::Module>("simple-lang", context);

    // Set target triple and data layout
    targetTriple = llvm::sys::getDefaultTargetTriple();
    module->setTargetTriple(targetTriple);

    std::string error;
    const llvm::Target* target = llvm::TargetRegistry::lookupTarget(targetTriple, error);
    if (!target) {
        llvm::errs() << error << "\n";
        exit(1);
    }

    llvm::TargetOptions opt;
    llvm::Optional<llvm::Reloc::Model> RM = llvm::None;

    targetMachine = std::unique_ptr<llvm::TargetMachine>(
        target->createTargetMachine(targetTriple, "generic", "", opt, RM));

    module->setDataLayout(targetMachine->createDataLayout());

    // Function Pass Manager for optimizations
    fpm = std::make_unique<llvm::legacy::FunctionPassManager>(module.get());
    // Add optimization passes if desired
    fpm->doInitialization();
}

llvm::LLVMContext& CodeGenContext::getContext() {
    return context;
}

llvm::Module* CodeGenContext::getModule() {
    return module.get();
}

llvm::IRBuilder<>& CodeGenContext::getBuilder() {
    return builder;
}

llvm::Type* CodeGenContext::getDoubleType() {
    return llvm::Type::getDoubleTy(context);
}

llvm::Function* CodeGenContext::currentFunction() {
    return builder.GetInsertBlock()->getParent();
}

llvm::TargetMachine* CodeGenContext::getTargetMachine() {
    return targetMachine.get();
}

void CodeGenContext::generateCode(BlockAST& root) {
    std::cout << "Generating code..." << std::endl;

    // Generate code for each statement in the root block
    root.codeGen(*this);

    llvm::verifyModule(*module, &llvm::errs());
    fpm->doFinalization();

    std::cout << "Code generation complete." << std::endl;
}

void CodeGenContext::pushBlock() {
    blocks.push_back(new CodeGenBlock());
}

void CodeGenContext::popBlock() {
    CodeGenBlock* top = blocks.back();
    blocks.pop_back();
    delete top;
}

void CodeGenContext::setSymbolValue(const std::string& name, llvm::Value* value) {
    blocks.back()->locals[name] = value;
}

llvm::Value* CodeGenContext::getSymbolValue(const std::string& name) {
    for (auto it = blocks.rbegin(); it != blocks.rend(); ++it) {
        auto value = (*it)->locals.find(name);
        if (value != (*it)->locals.end()) {
            return value->second;
        }
    }
    return nullptr;
}


==================================================================
FILE: ./src/main.cpp
==================================================================
// main.cpp

#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstring>

#include "ast.hpp"
#include "codegen.hpp"
#include "parser.hpp"

#include <llvm/Support/TargetSelect.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/Support/Host.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/Target/TargetMachine.h>

extern BlockAST* programBlock;
extern int yyparse();
extern FILE* yyin;

int main(int argc, char** argv) {
    bool debug = false;
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " source.sl [-d]" << std::endl;
        return 1;
    }

    // Check for debug flag
    for (int i = 2; i < argc; ++i) {
        if (strcmp(argv[i], "-d") == 0 || strcmp(argv[i], "--debug") == 0) {
            debug = true;
            yydebug = 1;
        }
    }

    // Initialize LLVM
    llvm::InitializeNativeTarget();
    llvm::InitializeNativeTargetAsmPrinter();
    llvm::InitializeNativeTargetAsmParser();

    // Set input file
    std::cout << "Opening " << argv[1] << std::endl;
    yyin = fopen(argv[1], "r");
    if (!yyin) {
        std::cerr << "Error: Failed to open " << argv[1] << std::endl;
        return 1;
    }

    std::cout << "Parsing..." << std::endl;
    if (yyparse()) {
        std::cerr << "Error parsing!" << std::endl;
        return 1;
    }

    // Generate code
    CodeGenContext context;
    context.generateCode(*programBlock);

    // Print the generated LLVM IR
    std::cout << "\nGenerated LLVM IR:" << std::endl;
    std::cout << "==================" << std::endl;
    context.getModule()->print(llvm::outs(), nullptr);
    std::cout << "==================" << std::endl;

    // Write LLVM IR to file
    std::error_code EC;
    llvm::raw_fd_ostream dest("output.ll", EC);
    if (EC) {
        llvm::errs() << "Could not open file: " << EC.message() << "\n";
        return 1;
    }
    context.getModule()->print(dest, nullptr);
    dest.flush();

    // Generate object code
    llvm::legacy::PassManager pass;
    llvm::raw_fd_ostream destObj("output.o", EC);
    if (EC) {
        llvm::errs() << "Could not open file: " << EC.message() << "\n";
        return 1;
    }

    llvm::TargetMachine* targetMachine = context.getTargetMachine();
    auto FileType = llvm::CGFT_ObjectFile;

    if (targetMachine->addPassesToEmitFile(pass, destObj, nullptr, FileType)) {
        llvm::errs() << "TargetMachine can't emit a file of this type\n";
        return 1;
    }

    pass.run(*context.getModule());
    destObj.flush();

    std::cout << "Object code generated in 'output.o'" << std::endl;

    return 0;
}


==================================================================
FILE: ./src/ast.cpp
==================================================================
#include "ast.hpp"
#include "codegen.hpp"
#include <llvm/IR/Value.h>
#include <llvm/IR/Verifier.h>
#include <iostream>

llvm::Value* NumberExprAST::codeGen(CodeGenContext& context) {
    return llvm::ConstantFP::get(context.getContext(), llvm::APFloat(value));
}

llvm::Value* VariableExprAST::codeGen(CodeGenContext& context) {
    llvm::Value* value = context.getSymbolValue(name);
    if (!value) {
        std::cerr << "Unknown variable name: " << name << std::endl;
        return nullptr;
    }
    return context.getBuilder().CreateLoad(value, name.c_str());
}

llvm::Value* BinaryExprAST::codeGen(CodeGenContext& context) {
    llvm::Value* L = lhs->codeGen(context);
    llvm::Value* R = rhs->codeGen(context);
    if (!L || !R) return nullptr;

    switch (op) {
        case OpAdd:
            return context.getBuilder().CreateFAdd(L, R, "addtmp");
        case OpSub:
            return context.getBuilder().CreateFSub(L, R, "subtmp");
        case OpMul:
            return context.getBuilder().CreateFMul(L, R, "multmp");
        case OpDiv:
            return context.getBuilder().CreateFDiv(L, R, "divtmp");
        case OpLT:
            L = context.getBuilder().CreateFCmpULT(L, R, "lttmp");
            return context.getBuilder().CreateUIToFP(L, context.getDoubleType(), "booltmp");
        case OpGT:
            L = context.getBuilder().CreateFCmpUGT(L, R, "gttmp");
            return context.getBuilder().CreateUIToFP(L, context.getDoubleType(), "booltmp");
        case OpLE:
            L = context.getBuilder().CreateFCmpULE(L, R, "letmp");
            return context.getBuilder().CreateUIToFP(L, context.getDoubleType(), "booltmp");
        case OpGE:
            L = context.getBuilder().CreateFCmpUGE(L, R, "getmp");
            return context.getBuilder().CreateUIToFP(L, context.getDoubleType(), "booltmp");
        case OpEQ:
            L = context.getBuilder().CreateFCmpUEQ(L, R, "eqtmp");
            return context.getBuilder().CreateUIToFP(L, context.getDoubleType(), "booltmp");
        case OpNE:
            L = context.getBuilder().CreateFCmpUNE(L, R, "netmp");
            return context.getBuilder().CreateUIToFP(L, context.getDoubleType(), "booltmp");
        default:
            std::cerr << "Invalid binary operator" << std::endl;
            return nullptr;
    }
}

llvm::Value* AssignmentExprAST::codeGen(CodeGenContext& context) {
    llvm::Value* value = rhs->codeGen(context);
    if (!value) return nullptr;

    llvm::Value* var = context.getSymbolValue(lhs->getName());
    if (!var) {
        std::cerr << "Unknown variable name: " << lhs->getName() << std::endl;
        return nullptr;
    }
    context.getBuilder().CreateStore(value, var);
    return value;
}

llvm::Value* CallExprAST::codeGen(CodeGenContext& context) {
    llvm::Function* calleeF = context.getModule()->getFunction(callee);
    if (!calleeF) {
        std::cerr << "Unknown function referenced: " << callee << std::endl;
        return nullptr;
    }
    if (calleeF->arg_size() != arguments.size()) {
        std::cerr << "Incorrect # arguments passed" << std::endl;
        return nullptr;
    }

    std::vector<llvm::Value*> argsV;
    for (unsigned i = 0; i < arguments.size(); ++i) {
        argsV.push_back(arguments[i]->codeGen(context));
        if (!argsV.back()) return nullptr;
    }

    return context.getBuilder().CreateCall(calleeF, argsV, "calltmp");
}

llvm::Value* ExpressionStmtAST::codeGen(CodeGenContext& context) {
    return expression->codeGen(context);
}

llvm::Value* BlockAST::codeGen(CodeGenContext& context) {
    llvm::Value* last = nullptr;
    for (auto stmt : statements) {
        last = stmt->codeGen(context);
    }
    return last;
}

llvm::Value* VariableDeclarationAST::codeGen(CodeGenContext& context) {
    llvm::Value* init = nullptr;
    if (assignmentExpr) {
        init = assignmentExpr->codeGen(context);
    } else {
        init = llvm::ConstantFP::get(context.getContext(), llvm::APFloat(0.0));
    }

    llvm::AllocaInst* alloc = context.getBuilder().CreateAlloca(
        context.getDoubleType(), 0, name.c_str());
    context.getBuilder().CreateStore(init, alloc);
    context.setSymbolValue(name, alloc);
    return alloc;
}

llvm::Value* FunctionAST::codeGen(CodeGenContext& context) {
    std::vector<llvm::Type*> argTypes(arguments.size(), context.getDoubleType());

    llvm::FunctionType* funcType = llvm::FunctionType::get(
        context.getDoubleType(), argTypes, false);

    llvm::Function* function = llvm::Function::Create(
        funcType, llvm::Function::ExternalLinkage, name, context.getModule());

    if (name == "main") {
        // Set the return type to 'int' for the main function
        funcType = llvm::FunctionType::get(
            llvm::Type::getInt32Ty(context.getContext()), argTypes, false);
        function->setName("main");
        function->setReturnType(llvm::Type::getInt32Ty(context.getContext()));
    }

    // Set names for all arguments
    unsigned idx = 0;
    for (auto& arg : function->args()) {
        arg.setName(arguments[idx++]->getName());
    }

    // Create a new basic block to start insertion into
    llvm::BasicBlock* bb = llvm::BasicBlock::Create(context.getContext(), "entry", function);
    context.getBuilder().SetInsertPoint(bb);

    context.pushBlock();

    idx = 0;
    for (auto& arg : function->args()) {
        llvm::AllocaInst* alloc = context.getBuilder().CreateAlloca(
            context.getDoubleType(), 0, arg.getName());
        context.getBuilder().CreateStore(&arg, alloc);
        context.setSymbolValue(arg.getName(), alloc);
    }

    body->codeGen(context);

    if (llvm::verifyFunction(*function, &llvm::errs())) {
        std::cerr << "Error constructing function: " << name << std::endl;
        function->eraseFromParent();
        context.popBlock();
        return nullptr;
    }

    context.popBlock();
    return function;
}

llvm::Value* IfAST::codeGen(CodeGenContext& context) {
    llvm::Value* condV = condition->codeGen(context);
    if (!condV) return nullptr;

    condV = context.getBuilder().CreateFCmpONE(
        condV, llvm::ConstantFP::get(context.getContext(), llvm::APFloat(0.0)), "ifcond");

    llvm::Function* function = context.getBuilder().GetInsertBlock()->getParent();

    llvm::BasicBlock* thenBB = llvm::BasicBlock::Create(context.getContext(), "then", function);
    llvm::BasicBlock* elseBB = llvm::BasicBlock::Create(context.getContext(), "else");
    llvm::BasicBlock* mergeBB = llvm::BasicBlock::Create(context.getContext(), "ifcont");

    if (elseBlock) {
        context.getBuilder().CreateCondBr(condV, thenBB, elseBB);
    } else {
        context.getBuilder().CreateCondBr(condV, thenBB, mergeBB);
    }

    // Emit then block
    context.getBuilder().SetInsertPoint(thenBB);
    thenBlock->codeGen(context);
    context.getBuilder().CreateBr(mergeBB);

    // Emit else block
    if (elseBlock) {
        function->getBasicBlockList().push_back(elseBB);
        context.getBuilder().SetInsertPoint(elseBB);
        elseBlock->codeGen(context);
        context.getBuilder().CreateBr(mergeBB);
    }

    // Emit merge block
    function->getBasicBlockList().push_back(mergeBB);
    context.getBuilder().SetInsertPoint(mergeBB);

    return nullptr;
}

llvm::Value* WhileAST::codeGen(CodeGenContext& context) {
    llvm::Function* function = context.getBuilder().GetInsertBlock()->getParent();

    llvm::BasicBlock* condBB = llvm::BasicBlock::Create(context.getContext(), "cond", function);
    llvm::BasicBlock* loopBB = llvm::BasicBlock::Create(context.getContext(), "loop");
    llvm::BasicBlock* afterBB = llvm::BasicBlock::Create(context.getContext(), "afterloop");

    context.getBuilder().CreateBr(condBB);

    // Condition block
    context.getBuilder().SetInsertPoint(condBB);
    llvm::Value* condV = condition->codeGen(context);
    if (!condV) return nullptr;
    condV = context.getBuilder().CreateFCmpONE(
        condV, llvm::ConstantFP::get(context.getContext(), llvm::APFloat(0.0)), "loopcond");
    context.getBuilder().CreateCondBr(condV, loopBB, afterBB);

    // Loop block
    function->getBasicBlockList().push_back(loopBB);
    context.getBuilder().SetInsertPoint(loopBB);
    body->codeGen(context);
    context.getBuilder().CreateBr(condBB);

    // After loop block
    function->getBasicBlockList().push_back(afterBB);
    context.getBuilder().SetInsertPoint(afterBB);

    return nullptr;
}

llvm::Value* ReturnAST::codeGen(CodeGenContext& context) {
    llvm::Value* retVal = expression->codeGen(context);
    if (!retVal) {
        return nullptr;
    }

    if (context.currentFunction()->getName() == "main") {
        // Convert return value to int32 for main function
        retVal = context.getBuilder().CreateFPToSI(
            retVal, llvm::Type::getInt32Ty(context.getContext()), "retint");
        return context.getBuilder().CreateRet(retVal);
    } else {
        return context.getBuilder().CreateRet(retVal);
    }
}
